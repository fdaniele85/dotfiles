#! /home/daniele/Sync/scripts/venv/bin/python3

import os
import sys
import re
import subprocess
import datetime
import random
import logging
import time

from sys import stderr

import argparse

temporanei=set()

def removeTmpFiles(dir):
    for f in temporanei:
        if os.path.exists(f):
            print("Rimuovo file temporaneo", f)
            os.remove(f)

    for f in os.listdir("/tmp/"):
    	if re.search("^log\d+$", f):
    		print("Rimuovo file di log", f)
    		os.remove(os.path.join("/tmp/", f))

parser = argparse.ArgumentParser(description='test')

optional = parser._action_groups.pop()

requiredNamed = parser.add_argument_group('required named arguments')
requiredNamed.add_argument("--alg", help="Algorithm directory", required=True)
requiredNamed.add_argument("--res", help="Results directory", required=True)
requiredNamed.add_argument("--ins", help="Instances directory", required=True)


optional.add_argument("--thread", help="Maximum threads",
                    type=int, default=1)
optional.add_argument("--shuffle", help="Shuffle tests")
optional.add_argument("--tmp", help="Result temp folder")
optional.add_argument("--hostname", help="Overwrite hostname")
optional.add_argument("--seeds", help="Number of different seeds",
                    type=int, default=1)
optional.add_argument("--ext", help="Instances ext (without point)")
optional.add_argument("--noseed", action='store_true', help="Instances ext (without point)")
optional.add_argument("--time", help='Max time (in seconds)', type=int)

parser._action_groups.append(optional)

args = parser.parse_args()

algDir = args.alg
risDir = args.res
instanceDir = args.ins
threads = args.thread
shuffle = args.shuffle
tmp = args.tmp
seeds = args.seeds
ext = args.ext
max_time = args.time

if ext is None:
    ext = ".txt"

if tmp:
    if not os.path.isdir(tmp):
        os.makedirs(tmp)

# if len(sys.argv) < 4:
#     print >> stderr, "Usage:", os.path.basename(sys.argv[0]), "algDir risDir instanceDir [threadMassimi [shuffle]]"
#     exit(1)
#
# (algDir, risDir, instanceDir) = sys.argv[1:4]
#
# threads = 1
# if len(sys.argv) >= 5:
#     threads = int(sys.argv[4])

hostname = os.uname()[1]
if args.hostname:
    hostname = args.hostname

os.makedirs

mancanti = []

risDirAbs = os.path.abspath(risDir)

istanze={}

def getInputFiles(insDir):
    files = []
    if os.path.isdir(insDir):
        for root, d, i_files in os.walk(insDir):
            for f in i_files:
            	if re.search(ext+"$", f):
            		inputFile = os.path.join(root, f)
            		files.append(inputFile)
    else:
        file1 = open(insDir, 'r') 
  
        while True:
            line = file1.readline()

            if not line: 
                break

            if not line.startswith('#'):
                files.append(line.strip())
    return files

def getAlgs(algDir):
    if os.path.isdir(algDir):
        return [os.path.join(algDir, file) for file in os.listdir(algDir)]
    else:
        return [algDir]

try:
    # files = {}
    # for root, d, files in os.walk(instanceDir):
    #     for f in files:
    #         for alg in os.listdir(algDir):
    #         	if re.search("\.no$", alg):
    #         		continue
            		
    #             if re.search("\."+ext+"$", f):
    #                 for s in range(0, seeds):
    #                     inputFile = os.path.join(root, f)

    #                     if args.noseed:
    #                     	risFile = re.sub("\."+ext+"$", ".ris", f)
    #                     else:
    #                     	risFile = re.sub("\."+ext+"$", "_"+str(s)+".ris", f)

    #                     outDir = os.path.join(risDirAbs, hostname, alg)
    #                     if (not os.path.isdir(outDir)):
    #                         os.makedirs(outDir)

    #                     risFile = os.path.join(outDir, risFile)

    #                     #print risFile
    #                     if (not os.path.exists(risFile)):
    #                         algAbs = os.path.abspath(os.path.join(algDir, alg))
    #                         inputFileAbs = os.path.abspath(inputFile)
    #                         mancanti.append((algAbs, inputFileAbs, risFile, str(s)))
    #                        istanze[inputFileAbs] = random.random()

    files = getInputFiles(instanceDir)
    print(files)

    for alg in getAlgs(algDir):
    	if re.search("\.no$", alg):
    		continue

    	for inputFile in files:
            for s in range(0, seeds):

                f = os.path.basename(inputFile)

                if args.noseed:
                    risFile = re.sub(ext+"$", ".ris", f)
                else:
                	risFile = re.sub(ext+"$", "_"+str(s)+".ris", f)

                outDir = os.path.join(risDirAbs, hostname, os.path.basename(alg))
                if (not os.path.isdir(outDir)):
                    os.makedirs(outDir)

                risFile = os.path.join(outDir, risFile)

                print(risFile)
                if (not os.path.exists(risFile)):
                    algAbs = os.path.abspath(alg)
                    print(algAbs)
                    inputFileAbs = os.path.abspath(inputFile)
                    mancanti.append((algAbs, inputFileAbs, risFile, str(s)))
                    istanze[inputFileAbs] = random.random()

    mancanti.sort(key=lambda x: x[1])

    if args.shuffle:
    	if args.shuffle == 'partial':
    		mancanti.sort(key=lambda x: istanze[x[1]])
    	elif args.shuffle == 'seed':
    		mancanti.sort(key=lambda x: (x[3], x[1]))
    	else:
        	random.shuffle(mancanti)

    for t in mancanti:
    	print(t[0], t[1])

    #print len(mancanti)


    lavori = []
    logs = []
    for i in range(0, threads):
        logs.append("/tmp/log"+str(i+1))

    logging.basicConfig(filename='/tmp/log0', filemode='w', format='%(name)s - %(levelname)s - %(message)s', level=logging.INFO)
    start = time.time()
    while len(mancanti) > 0 or len(lavori) > 0:
        while (len(lavori) < threads) and len(mancanti) > 0:
            logging.info("%s (%d)" % (datetime.datetime.now(), len(mancanti)))
            print(datetime.datetime.now(), "(%d)" % (len(mancanti)))
            t = mancanti[0]
            mancanti.pop(0)

            if (os.path.exists(t[2])):
                print("Salto l'esecuzione di ", t[0], t[1])
                continue

            tmpFile = ''
            if args.tmp:
                tmpName = os.path.basename(t[1])
                tmpFile = os.path.join(args.tmp, tmpName)
                print(tmpFile)
                if (os.path.exists(tmpFile)):
                    print ("Salto l'esecuzione di ", t[0], t[1])
                    continue
                f = open(tmpFile, "w")
                f.write("running")
                f.close()
                temporanei.add(tmpFile)

            log = logs[0]
            logs.pop(0)

            if args.noseed:
                p = subprocess.Popen([t[0], "--log-file", log, t[1]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            else:
                p = subprocess.Popen([t[0], "--seed", t[3], "--log-file", log, t[1]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            logging.info("Eseguo %s %s (%s)" % (t[0], t[1], t[3]))
            print ("Eseguo", t[0], t[1], t[3])
            lavori.append((t, p, log))

        i = 0
        while i < len(lavori):
            l = lavori[i]
            t = l[0]
            p = l[1]
            log = l[2]

            poll = p.poll()
            if poll != None:
                out, err = p.communicate()

                f = open(t[2], "w")
                f.write(out.decode("utf-8"))
                f.close()
                if args.tmp:
                    tmpName = os.path.basename(t[1])
                    tmpFile = os.path.join(args.tmp, tmpName)
                    if os.path.exists(tmpFile):
                        os.remove(tmpFile)
                    temporanei.remove(tmpFile)
                print (out.decode("utf-8"))
                print (err.decode("utf-8"))
                lavori.pop(i)
                logs.append(log)

            i += 1

        if max_time is not None:
            if time.time() - start > max_time:
                print("Max time reached")
                break
    removeTmpFiles(args.tmp)
except KeyboardInterrupt:
    print ("\nInterruzione dell'utente")
    removeTmpFiles(args.tmp)
    sys.exit(1)
